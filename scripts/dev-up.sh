#!/usr/bin/env bash
set -euo pipefail

# One-command dev bootstrap: start Anvil + deps, deploy contracts, start services.

ROOT_DIR=$(cd "$(dirname "$0")/.." && pwd)
COMPOSE_FILE="$ROOT_DIR/docker-compose.dev.yml"
CONTRACTS_DIR="$ROOT_DIR/contracts"
ENV_CONTRACTS_FILE="$ROOT_DIR/ours-gpu/.env.contracts"

RPC_URL="${CHAIN_RPC_URL:-http://localhost:8545}"
CHAIN_ID="${CHAIN_ID:-31337}"
MNEMONIC_DEFAULT="test test test test test test test test test test test junk"
MNEMONIC="${WALLET_MNEMONIC:-$MNEMONIC_DEFAULT}"

# Explicit mnemonic indices for key actors in dev
# Defaults align with docker-compose.dev.yml service WALLET_INDEX values
DEPLOYER_INDEX="${DEPLOYER_INDEX:-${WALLET_INDEX:-0}}"
CONTROLLER1_INDEX="${CONTROLLER1_INDEX:-0}"
WORKER1_INDEX="${WORKER1_INDEX:-1}"
WORKER2_INDEX="${WORKER2_INDEX:-2}"
TEST_USER_INDEX="${TEST_USER_INDEX:-3}"

info() { echo "[dev-up] $*"; }
err() { echo "[dev-up][ERR] $*" >&2; }

require_cmd() {
  command -v "$1" >/dev/null 2>&1 || { err "Missing required command: $1"; exit 1; }
}

require_cmd docker
require_cmd cast
require_cmd forge
require_cmd curl

if ! docker compose version >/dev/null 2>&1; then
  err "Docker Compose (v2) is required."
  exit 1
fi

info "Starting base services (anvil, postgres, minio)"
docker compose -f "$COMPOSE_FILE" up -d anvil postgres minio

info "Waiting for anvil at $RPC_URL ..."
RPC_PROBE='{"jsonrpc":"2.0","id":1,"method":"web3_clientVersion","params":[]}'
for i in {1..60}; do
  if curl -sSf -X POST -H 'content-type: application/json' --data "$RPC_PROBE" "$RPC_URL" >/dev/null; then
    break
  fi
  sleep 0.5
done
if ! curl -sSf -X POST -H 'content-type: application/json' --data "$RPC_PROBE" "$RPC_URL" >/dev/null; then
  err "Anvil not responding at $RPC_URL"
  exit 1
fi

info "Building contracts"
(
  cd "$CONTRACTS_DIR"
  forge build -q
)

info "Deriving deployer private key (index=$DEPLOYER_INDEX)"
DEPLOYER_PK=$(cast wallet private-key --mnemonic "$MNEMONIC" --mnemonic-index "$DEPLOYER_INDEX" | tr -d '\r\n')
if [[ ! "$DEPLOYER_PK" =~ ^0x[0-9a-fA-F]{64}$ ]]; then
  err "Failed to derive deployer private key"
  exit 1
fi

deploy() {
  local target="$1"; shift
  local args=("$@")
  local out
  out=$(forge create "$target" \
    --rpc-url "$RPC_URL" \
    --private-key "$DEPLOYER_PK" \
    --root "$CONTRACTS_DIR" \
    --broadcast \
    ${args:+--constructor-args "${args[@]}"} \
    --json)
  # extract address (JSON or plaintext)
  local addr
  addr=$(printf '%s' "$out" | sed -n 's/.*"deployedTo"\s*:\s*"\(0x[0-9a-fA-F]\{40\}\)".*/\1/p')
  if [[ -z "$addr" ]]; then
    addr=$(printf '%s' "$out" | sed -n 's/.*Deployed to: \(0x[0-9a-fA-F]\{40\}\).*/\1/p')
  fi
  if [[ -z "$addr" ]]; then
    err "Failed to parse deployed address for $target. Raw: $out"
    exit 1
  fi
  echo "$addr"
}

info "Deploying RoleManager (AccessManager)"
ACCESS_MANAGER=$(deploy "src/RoleManager.sol:RoleManager")

info "Deploying OCUToken"
OCU_TOKEN=$(deploy "src/OCUToken.sol:OCUToken" "$ACCESS_MANAGER")

info "Deploying ControllerLicense"
CONTROLLER_LICENSE=$(deploy "src/ControllerLicense.sol:ControllerLicense" "$ACCESS_MANAGER" "ControllerNFT" "CTRL")

info "Deploying WorkerManager"
WORKER_MANAGER=$(deploy "src/WorkerManager.sol:WorkerManager" "$ACCESS_MANAGER" "$OCU_TOKEN" "$CONTROLLER_LICENSE")

info "Deploying OrgRegistry"
ORG_REGISTRY=$(deploy "src/OrgRegistry.sol:OrgRegistry" "$ACCESS_MANAGER")

info "Deploying JobManager"
JOB_MANAGER=$(deploy "src/JobManager.sol:JobManager" "$ACCESS_MANAGER" "$OCU_TOKEN" "$ORG_REGISTRY" "$CONTROLLER_LICENSE" "$WORKER_MANAGER")

mkdir -p "$(dirname "$ENV_CONTRACTS_FILE")"
cat > "$ENV_CONTRACTS_FILE" <<EOF
# Auto-generated by scripts/dev-up.sh
CHAIN_RPC_URL=$RPC_URL
CHAIN_ID=$CHAIN_ID

ACCESS_MANAGER_ADDRESS=$ACCESS_MANAGER
OCU_TOKEN_ADDRESS=$OCU_TOKEN
CONTROLLER_LICENSE_ADDRESS=$CONTROLLER_LICENSE
WORKER_MANAGER_ADDRESS=$WORKER_MANAGER
ORG_REGISTRY_ADDRESS=$ORG_REGISTRY
JOB_MANAGER_ADDRESS=$JOB_MANAGER
EOF

info "Contract addresses written to $ENV_CONTRACTS_FILE"
printf "%s\n" \
  "ACCESS_MANAGER=$ACCESS_MANAGER" \
  "OCU_TOKEN=$OCU_TOKEN" \
  "CONTROLLER_LICENSE=$CONTROLLER_LICENSE" \
  "WORKER_MANAGER=$WORKER_MANAGER" \
  "ORG_REGISTRY=$ORG_REGISTRY" \
  "JOB_MANAGER=$JOB_MANAGER"

# -----------------------------------------------------------------------------
# Org tree setup (root -> university1 -> lab1) and membership assignment
# -----------------------------------------------------------------------------
info "Configuring OrgRegistry permissions (registerOrg/assignUser/assignNode)"
REGORG_SEL=$(cast sig "registerOrg(uint256,uint256,uint256,string)")
ASSIGN_USER_SEL=$(cast sig "assignUser(address,uint256)")
ASSIGN_NODE_SEL=$(cast sig "assignNode(address,uint256)")
cast send "$ACCESS_MANAGER" \
  "setTargetFunctionRole(address,bytes4[],uint64)" \
  "$ORG_REGISTRY" "[$REGORG_SEL,$ASSIGN_USER_SEL,$ASSIGN_NODE_SEL]" 0 \
  --rpc-url "$RPC_URL" --private-key "$DEPLOYER_PK" >/dev/null

# Create organizations
# Note: Using virtual root (id=0). On a fresh deployment, first org will get id=1.
ROOT_NAME="root"
UNI1_NAME="university1"
LAB1_NAME="lab1"
BASE_RATE=100
MARKUP=10

info "Registering org: $UNI1_NAME (child of virtual root 0)"
cast send "$ORG_REGISTRY" "registerOrg(uint256,uint256,uint256,string)" 0 "$BASE_RATE" "$MARKUP" "$UNI1_NAME" \
  --rpc-url "$RPC_URL" --private-key "$DEPLOYER_PK" >/dev/null
info "Registering org: $LAB1_NAME (child of university1)"
cast send "$ORG_REGISTRY" "registerOrg(uint256,uint256,uint256,string)" 1 "$BASE_RATE" "$MARKUP" "$LAB1_NAME" \
  --rpc-url "$RPC_URL" --private-key "$DEPLOYER_PK" >/dev/null

# Bootstrap permissions and initial state: mint controller NFT and stake workers
info "Configuring ControllerLicense permissions (mint/burn/setURI)"
MINT_SEL=$(cast sig "mintController(address,string)")
BURN_SEL=$(cast sig "burnController(uint256)")
SETURI_SEL=$(cast sig "setControllerURI(uint256,string)")
cast send "$ACCESS_MANAGER" \
  "setTargetFunctionRole(address,bytes4[],uint64)" \
  "$CONTROLLER_LICENSE" "[$MINT_SEL,$BURN_SEL,$SETURI_SEL]" 0 \
  --rpc-url "$RPC_URL" --private-key "$DEPLOYER_PK" >/dev/null

# Derive commonly used addresses/keys from declared indices
CONTROLLER_ADDR=$(cast wallet address --mnemonic "$MNEMONIC" --mnemonic-index "$CONTROLLER1_INDEX")
WORKER1_ADDR=$(cast wallet address --mnemonic "$MNEMONIC" --mnemonic-index "$WORKER1_INDEX")
WORKER2_ADDR=$(cast wallet address --mnemonic "$MNEMONIC" --mnemonic-index "$WORKER2_INDEX")
WORKER1_PK=$(cast wallet private-key --mnemonic "$MNEMONIC" --mnemonic-index "$WORKER1_INDEX" | tr -d '\r\n')
WORKER2_PK=$(cast wallet private-key --mnemonic "$MNEMONIC" --mnemonic-index "$WORKER2_INDEX" | tr -d '\r\n')
TEST_USER_ADDR=$(cast wallet address --mnemonic "$MNEMONIC" --mnemonic-index "$TEST_USER_INDEX")
info "Derived addresses -> controller1:$CONTROLLER_ADDR worker1:$WORKER1_ADDR worker2:$WORKER2_ADDR testUser:$TEST_USER_ADDR"

info "Minting ControllerLicense to controller1 ($CONTROLLER_ADDR)"
cast send "$CONTROLLER_LICENSE" \
  "mintController(address,string)" "$CONTROLLER_ADDR" "ipfs://controller1" \
  --rpc-url "$RPC_URL" --private-key "$DEPLOYER_PK" >/dev/null

FUND_AMT=1000000000000000000000   # 1,000 OCU with 18 decimals
STAKE_AMT=100000000000000000000   # 100 OCU with 18 decimals

info "Funding workers with OCU"
cast send "$OCU_TOKEN" "transfer(address,uint256)" "$WORKER1_ADDR" "$FUND_AMT" \
  --rpc-url "$RPC_URL" --private-key "$DEPLOYER_PK" >/dev/null
cast send "$OCU_TOKEN" "transfer(address,uint256)" "$WORKER2_ADDR" "$FUND_AMT" \
  --rpc-url "$RPC_URL" --private-key "$DEPLOYER_PK" >/dev/null

info "Workers approving and staking to WorkerManager"
cast send "$OCU_TOKEN" "approve(address,uint256)" "$WORKER_MANAGER" "$STAKE_AMT" \
  --rpc-url "$RPC_URL" --private-key "$WORKER1_PK" >/dev/null
cast send "$WORKER_MANAGER" "stake(uint256)" "$STAKE_AMT" \
  --rpc-url "$RPC_URL" --private-key "$WORKER1_PK" >/dev/null

cast send "$OCU_TOKEN" "approve(address,uint256)" "$WORKER_MANAGER" "$STAKE_AMT" \
  --rpc-url "$RPC_URL" --private-key "$WORKER2_PK" >/dev/null
cast send "$WORKER_MANAGER" "stake(uint256)" "$STAKE_AMT" \
  --rpc-url "$RPC_URL" --private-key "$WORKER2_PK" >/dev/null

# Assign membership: controller1 and worker1 -> university1 (orgId=1), worker2 -> lab1 (orgId=2)
info "Assigning org memberships"
cast send "$ORG_REGISTRY" "assignNode(address,uint256)" "$CONTROLLER_ADDR" 1 \
  --rpc-url "$RPC_URL" --private-key "$DEPLOYER_PK" >/dev/null
cast send "$ORG_REGISTRY" "assignNode(address,uint256)" "$WORKER1_ADDR" 1 \
  --rpc-url "$RPC_URL" --private-key "$DEPLOYER_PK" >/dev/null
cast send "$ORG_REGISTRY" "assignNode(address,uint256)" "$WORKER2_ADDR" 2 \
  --rpc-url "$RPC_URL" --private-key "$DEPLOYER_PK" >/dev/null
cast send "$ORG_REGISTRY" "assignNode(address,uint256)" "$TEST_USER_ADDR" 1 \
  --rpc-url "$RPC_URL" --private-key "$DEPLOYER_PK" >/dev/null

info "Starting controller, workers, and frontend (Nuxt) with contract env"
docker compose -f "$COMPOSE_FILE" up -d controller1 worker1 worker2 frontend nginx

info "Done. Controller: http://localhost:8000 (health at /health)"
info "Nuxt dev server: http://localhost:3000"
